\section{Resolver}\label{section:resolver}

The resolver exports just one function.

\begin{code}
module Resolver(
    solve
) where
\end{code}

\ignore{
\begin{code}
import Grammar

import Prelude hiding (lookup)
import Data.Map(lookup, insert, empty, union)
import Data.Foldable(foldlM)
\end{code}
}

This function takes in a valid mode structure and a query, and returns a list
of substitutions under which the query holds in the given module.

\begin{code}
solve :: Module -> Query -> [Theta]
solve p @ (Module pcs) (Query gs) =
  let (_, es) = match p (0, empty) gs pcs
  in map ((\e -> simplify e empty gs) . snd) es
\end{code}

Some additional work is done with the \texttt{simplify} function, as the
substitutions returned by the \texttt{match} function contain substitutions of
both variables in the query, and variables in the module (generated by
renaming).  \texttt{simplify} removes unnecessary definitions from the
substitutions, and completely ``expands'' every variable. Expansion is
necessary due to the fact that the subsitutions may look something like this:
\texttt{X = [\_G0], \_G0 = 1}. We'd like for this to simplify to the
substitution \texttt{X=[1]}.

Simplification is done by walking the propositions of a goal and adding all
variables that occur to the new substitution. The bindings are the completely
expanded bindngs in the original substitution.

\begin{code}
simplify :: Theta -> Theta -> [Value] -> Theta
simplify e e0 vs = foldl (simplify1 e) e0 vs

simplify1 :: Theta -> Theta -> Value -> Theta
simplify1 e e0 (Variable vn) =
  case lookup vn e of
    Just w -> insert vn (expand e w) e0
    Nothing -> empty
simplify1 e e0 (Symbol _ ps) = simplify e e0 ps
simplify1 e e0 (Eq v1 v2) =
  let e1 = simplify1 e e0 v1
      e2 = simplify1 e e0 v2
  in  union e1 e2
simplify1 _ e0 _ = e0
\end{code}

Expansion happens by walking the value and replacing all occurances of
variables by their respective binding in the substitution. Clearly this only
terminates for acyclic values.

\begin{code}
expand :: Theta -> Value -> Value
expand e v @ (Variable vn) =
  case lookup vn e of
    Just w -> expand e w
    Nothing -> v
expand e (Symbol sn ps) =
  (Symbol sn (map (expand e) ps))
expand e (Eq v1 v2) =
  let v11 = expand e v1
      v12 = expand e v2
  in  Eq v11 v12
expand _ v = v
\end{code}

\subsection{Most-general unifier}

The most-general unifier implementation follows the implementation suggested in
\cite[Figure 7.3 (page 134)]{torben}. The only exception is the unification of
two variables. If either variable is in the subsitution already, then the
substitution is returned, otherwise one of the variables inserted, pointing to
the other.

\begin{code}
mgu :: Theta -> [(Value, Value)] -> Maybe Theta
mgu e vs = foldlM mgu1 e vs

mgu1 :: Theta -> (Value, Value) -> Maybe Theta
mgu1 e (Variable xn, Variable yn) =
  case lookup xn e of
    Just _ -> Just e
    Nothing -> case lookup yn e of
                Just _ -> Just e
                Nothing -> Just (insert xn (Variable yn) e)
mgu1 e (Variable xn, v) =
  case lookup xn e of
    Just w -> mgu1 e (w, v)
    Nothing -> Just (insert xn v e)
mgu1 e (v, Variable xn) = mgu1 e (Variable xn, v)
mgu1 e (Symbol x xps, Symbol y yps) =
  if x == y
  then do
    vs <- zipOrFail xps yps
    mgu e vs
  else Nothing
mgu1 e (Eq v1 v2, Eq v3 v4) = do
  e1 <- mgu1 e (v1, v3)
  mgu1 e1 (v2, v4)
mgu1 _ _ = Nothing
\end{code}

The auxiliary \texttt{zipOrFail} provides for a means to ensure that when
looking the most-general unifier of two symbols, the number of paramters of the
two symbols is equal.

\begin{code}
zipOrFail :: [a] -> [b] -> Maybe [(a,b)]
zipOrFail (a : as) (b : bs) = do
  tl <- zipOrFail as bs
  return $ (a,b) : tl
zipOrFail [] [] = return []
zipOrFail _ _ = Nothing
\end{code}

\subsection{Renaming}

Renaming in general also follows the algorithm specified in \cite[Figure 7.4
(page 135)]{torben}. All heap variables are prefixed with \texttt{\_G} and
postfixed by unique integer index. As already mentioned, such a transformation
enforces no limitations on the user of the interpreter.

Although introduction of a state monad might have made renaming (and later
resolution) a little more readable, this is currently avoided. State is
therefore encoded in the parameters and return values of these functions. It
consists of an integer and a substitution. The integer is the index of the
next free variable.

\begin{code}
rename :: (Int, Theta) -> [Value] -> ((Int, Theta), [Value])
rename s [] = (s, [])
rename s (v : vs) =
  let (s1, ws) = rename s vs
      (s2, w) = rename1 s1 v
  in  (s2, w : ws)

rename1 :: (Int, Theta) -> Value -> ((Int, Theta), Value)
rename1 (i, e) (Variable xn) =
  case lookup xn e of
    Just w -> ((i, e), w)
    Nothing ->
      let i1 = i + 1
          wn = "_G" ++ (show i)
      in ((i1, insert xn (Variable wn) e), Variable wn)
rename1 s (Symbol x xps) =
  let (s1, xps1) = rename s xps
  in  (s1, Symbol x xps1)
rename1 s (Eq v1 v2) =
  let (s1, v11) = rename1 s v1
      (s2, v12) = rename1 s1 v2
  in  (s2, Eq v11 v12)
rename1 s v = (s,v)
\end{code}

\subsection{Resolution}

Resolution in general also follows the algorithm specified in \cite[Figure 7.4
(page 135)]{torben}. The return value of the \texttt{match} function indicates
whether the result was a result of a cut, or not. This is supposed to aid the
implementation of cuts, but fails to do so.

Perhaps the most interesting part is the last clause of the function. Here we
rename the head of a clause, and attempt to unify it with the current
proposition of the goal. If this succeeds, we rename the right-hand side of the
clause and expand it. Renaming is done with the substitution obtained from
renaming the head of the clause, i.e. we rename such that quantification is
maintained. Expansion is done with the substitution obtained from the
unification, i.e. we expand all variables on the right-hand side to the
corresponding values in the current goal.

We then continue to attempt matching the goal to the remaining clauses.
Depending on whether a cut is encountered or not, we may match again the
remaining clauses, or merely clauses who's heads cannot unify with the current
head, i.e. other \emph{predicates}. This functionality however has \emph{not}
been completed. Cuts therefore have no effect.

Equality is handled in a straight-forward way, if the values can be unified, we
continue to match the remaining goals with the obtained substitution.

The introduction of a cut is also handled in a straight-forward way. We match
the remaining goals and ``raise'' a cut exception.

Again, although a state monad could have aided readability, this was avoided in
the current implementation.

\begin{code}
data ResolverState
  = Regular
  | CutException
  deriving(Show, Eq)

match :: Module -> (Int, Theta) -> [Goal] -> [Clause] ->
  (ResolverState, [(Int, Theta)])
match _ _ _ [] = (Regular, [])
match _ s [] _ = (Regular, [s])
match p (i, e) ((Eq v1 v2):gs) cs =
  case mgu1 e (v1, v2) of
    Just e1 -> match p (i, e1) gs cs
    Nothing -> (Regular, [])
match p s (Cut : gs) cs =
  let (_, es) = match p s gs cs
  in (CutException, es)
match p @ (Module pcs) (i, e) (g:gs) ((Clause l r) : cs) =
  let
    ((i1, e1), l1) = rename1 (i, empty) l
    (x1, es1) = case mgu1 e (g, l1) of
            Just e2 ->
              let (_, r1) = rename (i1, e1) r
                  r2 = map (expand e2) r1
              in match p (i1, e2) (r2 ++ gs) pcs
            Nothing -> (Regular, [])
    (x2, es2) = match p (i, e) (g:gs) cs
    (x3, es3) = match p (i, e) (g:gs) (removePredicate l cs)
  in (Regular, es1 ++ es2) -- TODO: do cut magic.
\end{code}

The following function will remove all clauses from a list of clauses who's
heads unify successfully with the given value. This is used to cut to other
predicates in a list of clauses.

\begin{code}
removePredicate :: Value -> [Clause] -> [Clause]
removePredicate p (c @ (Clause l _) : cs) =
  let cs' = removePredicate p cs
  in case mgu1 empty (p, l) of
      Just _ -> cs'
      Nothing -> c : cs'
removePredicate _ [] = []
\end{code}
