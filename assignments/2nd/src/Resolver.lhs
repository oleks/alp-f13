\section{Resolver}\label{section:resolver}

The resolver exports just one function.

\begin{code}
module Resolver(
    solve
) where
\end{code}

\ignore{
\begin{code}
import Grammar

import Prelude hiding (lookup)
import Data.Map(lookup, insert, empty, union)
import Data.Foldable(foldlM)
\end{code}
}

This function takes in a valid mode structure and a query, and returns a list
of substitutions under which the query holds in the given module.

\begin{code}
solve :: Module -> Query -> [Theta]
solve p @ (Module pcs) (Query gs) =
  let (_, es) = match p (0, empty) gs pcs
  in map ((\e -> simplify e empty gs) . snd) es
\end{code}

Some additional work is done with the \texttt{simplify} function, as the
substitutions returned by the \texttt{match} function contain substitutions of
both variables in the query, and variables in the module (generated by
renaming).  \texttt{simplify} removes unnecessary definitions from the
substitutions, and completely ``expands'' every variable. Expansion is
necessary due to the fact that the subsitutions may look something like this:
\texttt{X = [\_G0], \_G0 = 1}. We'd like for this to simplify to the
substitution \texttt{X=[1]}.

Simplification is done by walking the propositions of a goal and adding all
variables that occur to the new substitution. The bindings are the completely
expanded bindngs in the original substitution.

\begin{code}
simplify :: Theta -> Theta -> [Value] -> Theta
simplify e e0 vs = foldl (simplify1 e) e0 vs

simplify1 :: Theta -> Theta -> Value -> Theta
simplify1 e e0 (Variable vn) =
  case lookup vn e of
    Just w -> insert vn (expand e w) e0
    Nothing -> empty
simplify1 e e0 (Symbol _ ps) = simplify e e0 ps
simplify1 e e0 (Eq v1 v2) =
  let e1 = simplify1 e e0 v1
      e2 = simplify1 e e0 v2
  in  union e1 e2
simplify1 _ e0 _ = e0
\end{code}

Expansion happens by walking the value and replacing all occurances of
variables by their respective binding in the substitution. Clearly this only
terminates for acyclic values.

\begin{code}
expand :: Theta -> Value -> Value
expand e v @ (Variable vn) =
  case lookup vn e of
    Just w -> expand e w
    Nothing -> v
expand e (Symbol sn ps) =
  (Symbol sn (map (expand e) ps))
expand e (Eq v1 v2) =
  let v11 = expand e v1
      v12 = expand e v2
  in  Eq v11 v12
expand _ v = v
\end{code}

\subsection{Most-general unifier}

\begin{code}
mgu :: Theta -> [(Value, Value)] -> Maybe Theta
mgu e vs = foldlM mgu1 e vs

mgu1 :: Theta -> (Value, Value) -> Maybe Theta
mgu1 e (Variable xn, Variable yn) =
  case lookup xn e of
    Just _ -> Just e
    Nothing -> case lookup yn e of
                Just _ -> Just e
                Nothing -> Just (insert xn (Variable yn) e)
mgu1 e (Variable xn, v) =
  case lookup xn e of
    Just w -> mgu1 e (w, v)
    Nothing -> Just (insert xn v e)
mgu1 e (v, Variable xn) = mgu1 e (Variable xn, v)
mgu1 e (Symbol x xps, Symbol y yps) =
  if x == y
  then do
    vs <- zipOrFail xps yps
    mgu e vs
  else Nothing
mgu1 e (Eq v1 v2, Eq v3 v4) = do
  e1 <- mgu1 e (v1, v3)
  mgu1 e1 (v2, v4)
mgu1 _ _ = Nothing
\end{code}

The auxiliary \texttt{zipOrFail} provides for a means to ensure that when
looking the most-general unifier of two symbols, the number of paramters of the
two symbols is equal.

\begin{code}
zipOrFail :: [a] -> [b] -> Maybe [(a,b)]
zipOrFail (a : as) (b : bs) = do
  tl <- zipOrFail as bs
  return $ (a,b) : tl
zipOrFail [] [] = return []
zipOrFail _ _ = Nothing
\end{code}

\subsection{Renaming}

\begin{code}
rename :: (Int, Theta) -> [Value] -> ((Int, Theta), [Value])
rename s [] = (s, [])
rename s (v : vs) =
  let (s1, ws) = rename s vs
      (s2, w) = rename1 s1 v
  in  (s2, w : ws)

rename1 :: (Int, Theta) -> Value -> ((Int, Theta), Value)
rename1 (i, e) (Variable xn) =
  case lookup xn e of
    Just w -> ((i, e), w)
    Nothing ->
      let i1 = i + 1
          wn = "_G" ++ (show i)
      in ((i1, insert xn (Variable wn) e), Variable wn)
rename1 s (Symbol x xps) =
  let (s1, xps1) = rename s xps
  in  (s1, Symbol x xps1)
rename1 s (Eq v1 v2) =
  let (s1, v11) = rename1 s v1
      (s2, v12) = rename1 s1 v2
  in  (s2, Eq v11 v12)
rename1 s v = (s,v)
\end{code}

\subsection{Resolution}

\begin{code}
data ResolverState
  = Regular
  | CutException
  deriving(Show, Eq)

match :: Module -> (Int, Theta) -> [Goal] -> [Clause] ->
  (ResolverState, [(Int, Theta)])
match _ _ _ [] = (Regular, [])
match _ s [] _ = (Regular, [s])
match p (i, e) ((Eq v1 v2):gs) cs =
  case mgu1 e (v1, v2) of
    Just e1 -> match p (i, e1) gs cs
    Nothing -> (Regular, [])
match p s (Cut : gs) cs =
  let (_, es) = match p s gs cs
  in (CutException, es)
match p @ (Module pcs) (i, e) (g:gs) ((Clause l r) : cs) =
  let
    ((i1, e1), l1) = rename1 (i, empty) l
    (x1, es1) = case mgu1 e (g, l1) of
            Just e2 ->
              let (_, r1) = rename (i1, e1) r
                  r2 = map (expand e2) r1
              in match p (i1, e2) (r2 ++ gs) pcs
            Nothing -> (Regular, [])
    (x2, es2) = match p (i, e) (g:gs) cs
    (x3, es3) = match p (i, e) (g:gs) (removePredicate l cs)
  in case x1 of
    Regular -> case x2 of
      Regular -> (Regular, es1 ++ es2)
      CutException -> (CutException, es1 ++ es2)
    CutException -> case x3 of
      Regular -> (CutException, es1 ++ es3)
      CutException -> (Regular, es3)

removePredicate :: Value -> [Clause] -> [Clause]
removePredicate p (c @ (Clause l _) : cs) =
  let cs' = removePredicate p cs
  in case mgu1 empty (p, l) of
      Just _ -> cs'
      Nothing -> c : cs'
removePredicate _ [] = []

\end{code}

\ignore{
\begin{code}
{-
l_0 = Symbol "p" [Variable "A"]
r_0 = [Symbol "q" [Variable "A"]
l_1 = Symbol "append" [
    Symbol "cons" [Variable "A", Variable "As"],
    Variable "Bs",
    Symbol "cons" [Variable "A", Variable "Cs"]
  ]
r_1 = [Symbol "append" [Variable "As", Variable "Bs", Variable "Cs"]]
g = Symbol "append" [
    Variable "As",
    Symbol "nil" [],
    Symbol "cons" [
      Symbol "1" [],
      Symbol "nil" []
    ]
  ]

((i1_2, e1_2), l1_2) = rename1 (i1_1, empty) l_0
Just e2_2 = mgu1 e2_1 (r1_1, l1_2)

(_, [r1_2]) = rename (i1_2, e1_2) r_0

((i1_3, e1_3), l1_3) = rename1 (i1_2, empty) l_1_0
Just e2_3 = mgu1 e2_2 (r1_2, l1_3)

(_, [r1_3]) = rename (i1_3, e1_3) r_1_0

((i1_4, e1_4), l1_4) = rename1 (i1_3, empty) l_1_0
Just e2_4 = mgu1 e2_3 (r1_3, l1_4)

(_, [r1_4]) = rename (i1_4, e1_4) r_1_0

((i1_5, e1_5), l1_5) = rename1 (i1_4, empty) l_0_0
Just e2_5 = mgu1 e2_4 (r1_4, l1_5)

(_, [r1_5]) = rename (i1_5, e1_5) r_0_0
-}
\end{code}
}

